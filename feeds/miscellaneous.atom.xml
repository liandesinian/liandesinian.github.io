<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>莲的思念's blog</title><link href="/" rel="alternate"></link><link href="/feeds/miscellaneous.atom.xml" rel="self"></link><id>/</id><updated>2015-06-13T15:00:00+08:00</updated><entry><title>Nmap笔记</title><link href="/article/miscellaneous/Nmap%E7%AC%94%E8%AE%B0.html" rel="alternate"></link><updated>2015-06-13T15:00:00+08:00</updated><author><name>莲的思念</name></author><id>tag:,2015-06-13:article/miscellaneous/Nmap笔记.html</id><summary type="html">&lt;h1&gt;Nmap&lt;/h1&gt;
&lt;h2&gt;目标&lt;/h2&gt;
&lt;p&gt;可以使用CIDR或是针对某个范围，每段都可以指定范围为0-255
-iL &lt;inputfilename&gt;：可以从文件中读取目标
-iR &lt;hostnum&gt;：选择几个随机的目标，对于特定的私有地址，组播等会掠过。参数0表示无休止的扫描
--exclude &lt;host1,host2...&gt;：排除几个目标&lt;/p&gt;
&lt;h2&gt;主机发现&lt;/h2&gt;
&lt;p&gt;若没有选项，则发送一个ICMP请求报文，TCP SYN报文到443端口，一个TCP ACK报文到80端口和一个ICMP时间戳请求。
-sL：只是单纯的列出目标网段的主机，都不发送任何包，不过仍然执行反向DNS解析
-sn：不进行端口扫描，只扫描存活主机。建立轻链接，不会引起目标主机太多关注。结合-P*可以绕过防火墙。
-Pn：不进行ping。假定指定的主机都是存活的，对每一台指定主机都按要求进行扫描。
-PS &lt;port list&gt;：对指定端口进行TCP SYN扫描。目标主机收到TCP SYN包后，若端口开放，则会回应SYN/ACK包，若是关闭则回应RST包，因为无需建立链接，所以扫描主机会回应RST包进行关闭
-PA &lt;port list&gt;：对指定端口进行TCP ACK扫描。发送ACK包，但是目标主机则回应RST包（因为没有建立链接）。有些时候，防火墙使用无状态的规则封锁外端的SYN报文，除了一些公开服务器。这时-PS可能被封锁，而-PA则可以进行。而有些时候防火墙使用有状态的规则来封锁非预期的报文，这时SYN报文更有效。所以要结合-PS和-PA来进行探测。
-PU &lt;portlist&gt;：UDP ping。
-PE;-PP;-PM：ICMP ping。不过因为防火墙的限制，单纯的ICMP ping已经没有多大用了，如果是在内网扫描的话还是可以的。
-PO &lt;protocol list&gt;：IP 协议ping
-PR：ARP ping。在局域网中，比基于IP的ping更加快速和可靠。如果是在同一个局域网中，即使指定了不同的ping类型，ARP ping也会进行，要关闭可以指定--disable-arp-ping
-n：不用DNS域名解析&lt;/p&gt;
&lt;h2&gt;端口扫描&lt;/h2&gt;
&lt;h3&gt;状态&lt;/h3&gt;
&lt;p&gt;open：端口处于监听状态。
closed：端口关闭，不过可以判断出主机是存活的。
filtered：被过滤，无法判断是open还是closed
unfiltered：端口没有被过滤，但是无法判断是open还是closed，只有在使用ACK扫描时才会出现
open|filtered：无法判断是open还是filterd，可能防火墙把回应阻了，发生在UDP,FIN,Xmas扫描
closed|filtered：无法判断是closed还是filtered。只发生在使用IP Idle扫描&lt;/p&gt;
&lt;p&gt;-sS:TCP SYN扫描。并不建立完整的链接，相对不会引起注意。当收到syn/ack回应时认为是open的，收到rst回应时认为是closed，如果在一定时间内未收到包则认为是filtered
-sT：TCP connection扫描。建立一个完整的链接，会被目标主机记录下来。对端如果在日志中看到来自同一个IP的多个链接，则可以认为是被扫描了。
-sU:UDP扫描。因为UDP扫描比TCP扫描要慢而且困难，所以很多人会忽略这些端口。可以结合TCP扫描一起进行。为了区分open和filtered，加上-sV参数
-sN;-sF;-sX：TCP NULL,TCP FIN,Xmas扫描。通过一个微妙的方法来区分open和closed端口。如果目标端口是关闭的，发送一个不包含SYN,ACK,RST报文会导致收到一个RST返回报文，如果目标端口是开放的，则没有响应。NULL不设置任何TCP标志位，FIN设置FIN位，Xmas设置FIN,URG,PSH位。这些扫描方式的特点是可以绕过一些非状态的防火墙和包过滤路由器，另一个优势是比SYN扫描更加低调，不过不能太过依赖，多数IDS还是可以发现的。同时并非所有系统都遵循这一标准，像Windows不管端口是open还是closed都会返回RST包，这样就会把所有端口都标记为closed。但是这对于大多数的基于UNIX的系统还是有效的。不过这种扫描方式无法区分open和filtered
-sA：ACK扫描。无法决定是open还是closed，它用来发现防火墙的规则来确实是有状态的还是无状态的，以及哪些端口是被过滤的。当端口未被过滤是返回RST包，当端口被过滤时收不到包，只能区分是否被过滤。
--scanflags：定制扫描。通过指定标记位来设置扫描。同时可以设置该如何解释收到的包。
--sO：IP协议扫描。确定目标主机上支持哪些IP协议。可以用-p来选择协议号。协议扫描注意的是ICMP协议不可到达消息。收到任何协议的响应就标记为open，收到类型3,代码2的ICMP报文时认为从closed，其他情况认为是filtered。
-b： FTP bounce扫描。代理ftp链接允许用户连接到一台ftp服务器上，然后要求服务器发送文件给第三方主机，这导致ftp服务器对目标主机的端口进行扫描。大部分已经被修复了。&lt;/p&gt;
&lt;h2&gt;端口指定和扫描顺序&lt;/h2&gt;
&lt;p&gt;-p：可以指定端口号，协议号（-sO情况下），甚至是服务名
--exclude-ports &lt;port range&gt;：排除端口
--top-ports &lt;number&gt;：扫描开放概率最高的number个端口，默认为1000个&lt;/p&gt;
&lt;h2&gt;服务和版本发现&lt;/h2&gt;
&lt;p&gt;-sV：可以区分open和filtered
-O：操作系统探测&lt;/p&gt;
&lt;h2&gt;Nmap脚本引擎&lt;/h2&gt;
&lt;p&gt;允许用户写脚本（LUA语言）来自动化一些网络任务。脚本并不是在沙盒中运行，因此可能会损坏系统，所以除非信任，否则不要使用第三方的脚本。脚本位于：/usr/share/nmap/scripts/
-sC：使用默认的脚本
--script &lt;filename|category|directory&gt;:可以嵌入逻辑运算符and，or，not
--script-args &lt;name&gt;=&lt;value&gt;：脚本参数，逗号分隔&lt;/p&gt;
&lt;h2&gt;时间和性能&lt;/h2&gt;
&lt;p&gt;-T [0-5]：使用相应的扫描模板。模式0和1为了躲避IDS，同时会减慢扫描速度。模式2使用少量带块和目标主机资源，减慢扫描速度。模式3为默认的，不做任何事情。模式4加快扫描速度。模式5更快，可能会有失精准。一般可以使用-T4&lt;/p&gt;
&lt;h2&gt;防火墙/IDS躲避和欺骗&lt;/h2&gt;
&lt;p&gt;1、使用分片
-f：使用分片
--mtu &lt;MTU&gt;：设置mtu。自定义偏移大小，必须是8的整数倍
2、进行IP诱骗
-D &lt;decoy1,...&gt;：使用诱饵进行扫描，作为诱饵的主机必须处于up状态，可以有多个，加入ME表示本机
3、IP伪装：将发送包的IP地址改为其他的地址。如果既希望伪装IP，又希望获取回复包，可以使用idle scan
-S &lt;ip&gt;：源地址欺骗。配合-e 和 -Pn使用。-e：指定发包出口
4、伪装源端口：有些防火墙只允许特定端口的数据包通过，因此可以将发送的源端口都设定成特定的。
-g &lt;port number&gt;：源端口号欺骗。发送指定源端口的数据包&lt;/p&gt;
&lt;p&gt;--data-string &lt;string&gt;：给发送包附加自定义的数据
--data-length：附加指定数量的随机字节。
--spoof-mac：指定欺骗mac地址。0表示使用随机mac&lt;/p&gt;
&lt;h2&gt;输出&lt;/h2&gt;
&lt;p&gt;有5中输出格式。默认的是交互式输出，还有一种主要的是XML格式
-oX：输出成XML格式文件，文件名中可以带%H,%M,%S等与时间有关的参数。
-oN：类似交互式输出
-V：详细信息
-d：调试信息
--packet-trace：包发送和接收的信息
--resume：如果-oN日志被保留则可以恢复终止的扫描。&lt;/p&gt;
&lt;h2&gt;杂项&lt;/h2&gt;
&lt;p&gt;--send-eth：在数据链路层发送；--send-ip：在网络层发送
在运行时，可以进行交互，输入？查看选项&lt;/p&gt;</summary></entry><entry><title>Markdown笔记</title><link href="/article/miscellaneous/Markdown%E7%AC%94%E8%AE%B0.html" rel="alternate"></link><updated>2015-05-10T00:00:00+08:00</updated><author><name>莲的思念</name></author><id>tag:,2015-05-10:article/miscellaneous/Markdown笔记.html</id><summary type="html">&lt;p&gt;&lt;strong&gt;&lt;a href="http://wowubuntu.com/markdown/"&gt;原文地址&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;h2&gt;概述&lt;/h2&gt;
&lt;p&gt;Markdown是一种书写的格式，它的目标是称为一种适合网络的&lt;strong&gt;书写&lt;/strong&gt;语言。Markdown兼容HTML，不在markdown范围内的标签都可以直接在html里面撰写，直接加标签即可，除了&lt;code&gt;&amp;lt;div&amp;gt;&lt;/code&gt;,&lt;code&gt;&amp;lt;p&amp;gt;&lt;/code&gt;,&lt;code&gt;&amp;lt;table&amp;gt;&lt;/code&gt;,&lt;code&gt;&amp;lt;pre&amp;gt;&lt;/code&gt;需要在前后加上空行与其他段落进行区分，同时它们的开始和结尾标签不能用制表符或空格来缩进：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;这是一个普通段落

&lt;span class="nt"&gt;&amp;lt;table&amp;gt;&lt;/span&gt;
  &lt;span class="nt"&gt;&amp;lt;tr&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;td&amp;gt;&lt;/span&gt;foo&lt;span class="nt"&gt;&amp;lt;/td&amp;gt;&lt;/span&gt;
  &lt;span class="nt"&gt;&amp;lt;/tr&amp;gt;&lt;/span&gt;
&lt;span class="nt"&gt;&amp;lt;/table&amp;gt;&lt;/span&gt;

这是一个普通段落
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;在html区块内的markdown语法不会被处理。但是HTML的区段（行内）标签如 &lt;code&gt;&amp;lt;span&amp;gt;&lt;/code&gt; , &lt;code&gt;&amp;lt;cite&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;del&amp;gt;&lt;/code&gt;可以在Markdown的段落、列表或标题里随意使用，也可以直接用HTML标签。Markdown语法在区段（行内）标签间是有效的。&lt;/p&gt;
&lt;p&gt;在 HTML 文件中，有两个字符需要特殊处理： &lt;code&gt;&amp;lt;&lt;/code&gt; 和 &lt;code&gt;&amp;amp;&lt;/code&gt; 。 &lt;code&gt;&amp;lt;&lt;/code&gt; 符号用于起始标签，&lt;code&gt;&amp;amp;&lt;/code&gt; 符号则用于标记 HTML 实体，如果你只是想要显示这些字符的原型，你必须要使用实体的形式，像是 &lt;code&gt;&amp;amp;lt;&lt;/code&gt; 和 &lt;code&gt;&amp;amp;amp;&lt;/code&gt;。Markdown会自动转换html的实体。Markdown让你可以自然地书写字符，需要转换的由它来处理好了。如果你使用的 &lt;code&gt;&amp;amp;&lt;/code&gt; 字符是 HTML 字符实体的一部分，它会保留原状，否则它会被转换成 &lt;code&gt;&amp;amp;amp&lt;/code&gt;;。同样，如果 &lt;code&gt;&amp;lt;&lt;/code&gt; 作为标签的一部分不会转换，否则会转换成 &lt;code&gt;&amp;amp;lt;&lt;/code&gt;。不论是行内还是区块， &lt;code&gt;&amp;lt;&lt;/code&gt; 和 &lt;code&gt;&amp;amp;&lt;/code&gt; 两个符号都&lt;em&gt;一定&lt;/em&gt;会被转换成 HTML 实体。&lt;/p&gt;
&lt;h2&gt;段落和换行&lt;/h2&gt;
&lt;p&gt;一个markdown段落的前后要有一个以上的空行，普通段落不允许用缩进。同时一个markdown段落是由一个或多个连续的文本行组成的，因此一个Markdown段落允许有多行，但是其并不会将每一个换行符都转换为 &lt;code&gt;&amp;lt;br /&amp;gt;&lt;/code&gt;，因此即使在一个段落中有多行，显示的时候仍是在一行上。如果要&lt;em&gt;确实&lt;/em&gt;要强制 Markdown 插入 &lt;code&gt;&amp;lt;br /&amp;gt;&lt;/code&gt;，就在插入处输入两个以上的空格。&lt;/p&gt;
&lt;h2&gt;标题&lt;/h2&gt;
&lt;p&gt;在行首插入1到6个#，对应标题1到标题6，行尾无所谓，可以闭合，也可以不闭合&lt;/p&gt;
&lt;h2&gt;区块引用&lt;/h2&gt;
&lt;p&gt;在行首添加 &lt;code&gt;&amp;gt;&lt;/code&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&amp;gt; This is a blockquote with two paragraphs. Lorem ipsum dolor sit amet,
&amp;gt; consectetuer adipiscing elit. Aliquam hendrerit mi posuere lectus.
&amp;gt; Vestibulum enim wisi, viverra nec, fringilla in, laoreet vitae, risus.
&amp;gt; 
&amp;gt; Donec sit amet nisl. Aliquam semper ipsum sit amet velit. Suspendisse
&amp;gt; id sem consectetuer libero luctus adipiscing.
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;当然也可以偷懒只在每一个段落的开头添加&lt;code&gt;&amp;gt;&lt;/code&gt;。可以嵌套，只要加上不同数量的&lt;code&gt;&amp;gt;&lt;/code&gt;即可。&lt;/p&gt;
&lt;h2&gt;列表&lt;/h2&gt;
&lt;p&gt;Markdown支持有序列表和无序力表。无序列表使用&lt;code&gt;*&lt;/code&gt;,&lt;code&gt;+&lt;/code&gt;,&lt;code&gt;-&lt;/code&gt;作为列表标记。有序列表使用数字作为标记。列表标记放在最左边，标记后面一定要跟上一个以上的空格或制表符：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;* This is first
* This is second
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;当然，列表项目也支持多段落，但是每个项目下的每个段落都必须用4个空格或一个制表符缩进。如果项目内放进区块引用，&lt;code&gt;&amp;gt;&lt;/code&gt;就需要缩进。如果项目内含有代码区块，该代码区块就需要缩进两次，即8个空格或2个制表符。&lt;/p&gt;
&lt;h2&gt;代码区块&lt;/h2&gt;
&lt;p&gt;代码区块需要缩进4个空格或1个制表符，显示时这个缩进会被移除并转换为&lt;code&gt;&amp;lt;pre&amp;gt;&amp;lt;code&amp;gt;&lt;/code&gt;&lt;/p&gt;
&lt;h2&gt;分割线&lt;/h2&gt;
&lt;p&gt;可以在一行内输入三个以上的&lt;code&gt;*&lt;/code&gt;或&lt;code&gt;-&lt;/code&gt;，可以在之间加入空格，不能有其他东西。&lt;/p&gt;
&lt;hr /&gt;
&lt;h2&gt;链接&lt;/h2&gt;
&lt;p&gt;Markdown支持两种格式的链接：行内式和参考式。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;行内式：
This is [example](http://example.com)

参考式：
This is [example][id]
接着在文章的任意位置将链接定义的内容定义出来：
[id]: http://www.example.com  #冒号后需有一个以上的空格或制表符
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;强调&lt;/h2&gt;
&lt;p&gt;Markdown使用&lt;code&gt;*&lt;/code&gt;,&lt;code&gt;_&lt;/code&gt;作为标记，被其包围的字词被转换为&lt;code&gt;&amp;lt;em&amp;gt;&lt;/code&gt;，被两个&lt;code&gt;*&lt;/code&gt;或&lt;code&gt;_&lt;/code&gt;包围的会被转换为&lt;code&gt;&amp;lt;strong&amp;gt;&lt;/code&gt;。&lt;/p&gt;
&lt;h2&gt;代码&lt;/h2&gt;
&lt;p&gt;如果要标记一小段代码，可以用反引号（`）包起来&lt;/p&gt;
&lt;h2&gt;图片&lt;/h2&gt;
&lt;p&gt;Markdown使用和链接很相似的语法来标记图片，也分为行内式和参考式。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;行内式：
![example](/path/to/pic)
参考式：
![example][id]
[id]: /path/to/pic
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;其他&lt;/h2&gt;
&lt;p&gt;反斜杠&lt;code&gt;\&lt;/code&gt;被用来转义&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;\   反斜线
`   反引号
*   星号
_   底线
{}  花括号
[]  方括号
()  括弧
#   井字号
+   加号
-   减号
.   英文句点
!   惊叹号
&lt;/pre&gt;&lt;/div&gt;</summary></entry><entry><title>Pelican学习笔记</title><link href="/article/miscellaneous/Pelican%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html" rel="alternate"></link><updated>2015-05-10T00:00:00+08:00</updated><author><name>莲的思念</name></author><id>tag:,2015-05-10:article/miscellaneous/Pelican学习笔记.html</id><summary type="html">&lt;p&gt;Pelican是Python的一个包，用于生成静态站点，可以用reStructedText或Markdown语法格式来写内容。搭配上&lt;a href="https://pages.github.com/"&gt;github pages&lt;/a&gt;，很适合用来写博客。&lt;/p&gt;
&lt;h2&gt;快速入门&lt;/h2&gt;
&lt;p&gt;首先安装Pelican包&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;pip install pelican
pip install markdown
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;然后创建一个骨架&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;mkdir  ~/yoursite
cd ~/yoursite
pelican-quickstart
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;接着创建一个Markdown文件，具体语法可见此处&lt;a href="./Markdown笔记.html"&gt;Markdwon笔记&lt;/a&gt;，最后生成加本地预览&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;make devserver     #此选项可以在修改的同时即时生成
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;通过浏览器输入 &lt;code&gt;http://localhost:8000&lt;/code&gt; 即可。修改好后需要退出，可输入 &lt;code&gt;./develop_server.sh stop&lt;/code&gt; &lt;/p&gt;
&lt;h2&gt;安装pelican&lt;/h2&gt;
&lt;p&gt;可以使用上述所说的pip，也可以使用easy_install，或是直接下载pelican的源码进行安装&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;cd path-to-pelican-source
python setup.py install
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;当然，如果安装有Python的virtualenv，可以在安装pelican之前创建一个虚拟环境&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;virtualenv ~/pelican
source ~/pelican/bin/activate
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;当pelican安装完之后，有许多依赖被一起安装了进来：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;* feedgenerator 产生Atom反馈
* jinja2        用来支持模板
* pygments      语法高亮
* docutils      支持reStructuredText作为输出格式
* pytz          时区定义
* blinker       
* unidecode     ASCII到Unicode转换
* six           Python 2和Python 3兼容工具
* MarkupSafe    标记安全字符
* python-dateutil  读日期信息
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;东西挺多的，有时间再慢慢看看。。。&lt;/p&gt;
&lt;p&gt;当用 &lt;code&gt;pelican-quickstart&lt;/code&gt; 搭建完骨架后，可以看到生成了一堆文件&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;yourproject/
-- content
|   -- (pages)  #增加注入About、Contact等页面
-- output
-- develop_server.sh
-- fabfile.py
-- Makefile
-- pelicanconf.py   # Main settings file
-- publishconf.py   # Settings to use when ready to publish
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;写文章&lt;/h2&gt;
&lt;p&gt;Pelican可以从文章中读取元信息，比如说Title、Date、Author等&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;Title：My First article
Date: 2015-09-29 13:00
Authors: liandesinian
Summary: Test

This is first article
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Pelican会将之转换为html文件：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nt"&gt;&amp;lt;html&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;head&amp;gt;&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;lt;title&amp;gt;&lt;/span&gt;My First article&lt;span class="nt"&gt;&amp;lt;/title&amp;gt;&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;lt;meta&lt;/span&gt; &lt;span class="na"&gt;name=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;date&amp;quot;&lt;/span&gt; &lt;span class="na"&gt;content=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;2015-09-29 13:00&amp;quot;&lt;/span&gt; &lt;span class="nt"&gt;/&amp;gt;&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;lt;meta&lt;/span&gt; &lt;span class="na"&gt;name=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;authors&amp;quot;&lt;/span&gt; &lt;span class="na"&gt;content=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;liandesinian&amp;quot;&lt;/span&gt; &lt;span class="nt"&gt;/&amp;gt;&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;lt;meta&lt;/span&gt; &lt;span class="na"&gt;name=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;summary&amp;quot;&lt;/span&gt; &lt;span class="na"&gt;content=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;test&amp;quot;&lt;/span&gt; &lt;span class="nt"&gt;/&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;/head&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;body&amp;gt;&lt;/span&gt;
    This is first article
    &lt;span class="nt"&gt;&amp;lt;/body&amp;gt;&lt;/span&gt;
&lt;span class="nt"&gt;&amp;lt;/html&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;strong&gt;Note: &lt;/strong&gt; 除了Title是必须有的，其他的元信息都可以省略。如果Date被省略并且配置文件中的DEFAULT_DATE被设置成 &lt;code&gt;fs&lt;/code&gt; ，则Pelican会采用文件的 &lt;code&gt;ctime&lt;/code&gt;（是change，非create，与文件的属性和内容有关）「&lt;strong&gt;最好还是在创建文章是添加Date元信息，否则可能会出现问题&lt;/strong&gt;」，如果省略Category，会采用子目录的名称。若修改了一些设置但是没有能即时显现出来，可能是缓存的问题，在配置文件中加上 &lt;code&gt;LOAD_CONTENT_CACHE=False&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;pages：&lt;/strong&gt; 在contents目录下的pages目录中可以放置一些注入About和Contact的页面。&lt;/p&gt;
&lt;h3&gt;链接到内部文章&lt;/h3&gt;
&lt;p&gt;要链接到内部其他文章，可以使用&lt;code&gt;{filename}path/to/file&lt;/code&gt;语句，当然在Markdown中也有链接到内部其他文章的语句。当然除了可以链接到文章，这个语句还可以用来链接其他文件，诸如照片等，不过必须把这些文件所在的目录包含进pelicanconf.py的STATIC_PATHS中，pelican默认包含images目录。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Note: &lt;/strong&gt; status元信息可以为published（发布），hidden（不发布），draft（草稿，不发布）&lt;/p&gt;
&lt;h2&gt;发布站点&lt;/h2&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;pelican /path/to/your/content [-o /path/to/output] [-s /path/to/your/settings.py]
pelican -r  #监测修改
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;当然一开始的pelican-quicstart询问是否要快捷发布时，选择yes，那么会有Makefile，所以可以直接&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;make publish  #发布
make regenerator  #监测修改
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;配置文件&lt;/h2&gt;
&lt;p&gt;关于配置文件的选项有很多，在此不一一列举。需要注意几点：
    * 所有设置的标识符都是大写的，其值有数字，布尔，字典，元组和字符串
    * 支持的URL可以是绝对路径也可以是相对路径。相对路径在进行本地测试的时候很有用，绝对路径在发布的时候很有用。可是设置两个配置文件，分别用于本地测试和发布。
    * &lt;em&gt;_URL和&lt;/em&gt;_SAVE_AS用于定位和保存生成在output目录中的文件结构。 如果不想在output目录中生成，可以将其值设置为''
    * 关于主题可以自己创建，也可以下载别人的模板，然后在添加 &lt;code&gt;THEME&lt;/code&gt; 的值。&lt;/p&gt;
&lt;h2&gt;创建主题&lt;/h2&gt;
&lt;p&gt;后续补充。。。。&lt;/p&gt;
&lt;h2&gt;添加插件&lt;/h2&gt;
&lt;p&gt;后续补充。。。。&lt;/p&gt;</summary></entry><entry><title>Progit学习笔记</title><link href="/article/miscellaneous/Progit%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html" rel="alternate"></link><updated>2014-10-21T00:00:00+08:00</updated><author><name>莲的思念</name></author><id>tag:,2014-10-21:article/miscellaneous/Progit学习笔记.html</id><summary type="html">&lt;ul&gt;
&lt;li&gt;&lt;a href="#overview"&gt;概述&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href="#basic"&gt;Git 基础&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#branch"&gt;Git 分支&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#tool"&gt;Git 工具&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#manage"&gt;自定义Git&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id='overview'&gt;概述&lt;/h2&gt;

&lt;p&gt;Git和其他版本控制系统的主要差别在于Git并不保存前后变化的差异数据，它更像是把数据变化后的快照记录在一个微型的文件系统里。每次提交更新时，它会纵览一遍所有文件的指纹信息并作一快照，然后保存一个指向这个快照的索引。若文件没有变化，则Git不会保存，而是会对上一次保存的快照作一链接。如图所示。&lt;img alt="" src="http://7xn66o.com1.z0.glb.clouddn.com/progit/1.png" /&gt;Git近乎所有的操作都可以在本地执行，无需和服务器交互，速度快。所有保存在Git中的数据库中的东西都是用哈希值来索引的，因此可以保证数据的完整性。在Git中每个文件都有三种状态。已提交（commited），已暂存（staged），已修改（modified）。已提交表示文件被安全地保存在本地的数据库中，已暂存表示修改的文件已经被放在下次要提交的清单中，已修改表示文件已经被修改过了，但还未提交保存。因此文件在三个区域中进行流转：Git的本地数据目录，暂存区域和工作区域。如图：&lt;img alt="" src="http://7xn66o.com1.z0.glb.clouddn.com/progit/2.jpg" /&gt;
在工作目录中修改文件，然后把文件的快照保存到暂存区域，最后提交更新将文件快照转存到Git目录中。每个项目都有一个git目录，用来保存元数据和对象数据库。从项目中取出某个版本的所有文件和目录，用来开始工作的就叫做工作区域。暂存区域其实也就是一个文件，一般都放在git目录中。&lt;/p&gt;
&lt;h2 id="basic"&gt;Git 基础&lt;/h2&gt;

&lt;h3&gt;一、取得项目的仓库：&lt;/h3&gt;

&lt;p&gt;1 在现存的目录下通过导入所有文件来创建Git仓库：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;git init    #初始化
git add .   #添加所有文件到staged区域
git commit -m &amp;#39;...&amp;#39;   #提交到Git仓库
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;2 克隆现有仓库：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;git clone &lt;span class="nt"&gt;&amp;lt;i&amp;gt;&lt;/span&gt;url&lt;span class="nt"&gt;&amp;lt;/i&amp;gt;&lt;/span&gt;  #创建一个含.git目录的目录，并从同步后的仓库中拉出最新的数据
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;二、记录每次更新到仓库：&lt;/h3&gt;

&lt;p&gt;在工作区域中的文件不外乎两种状态：已跟踪的和未跟踪的。已跟踪的表示在之前的快照中已经有过它们的记录。工作一端时间后可能是未更新，已修改或已放入暂存区域。所有其他文件都是未跟踪的，既没有上次更新的快照，也没有放入暂存区域。如图&lt;img alt="" src="http://7xn66o.com1.z0.glb.clouddn.com/progit/3.jpg" /&gt;&lt;/p&gt;
&lt;p&gt;查看文件的状态：&lt;code&gt;git status&lt;/code&gt;。将工作目录中的文件放入暂存区域：&lt;code&gt;git add &amp;lt;file|.&amp;gt;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;如果要忽略某些文件，无需纳入Git目录中，也不希望一直出现在未跟踪列表中，比如说编译过程中产生的中间文件或是日志文件，可以创建一个.gitigmore文件，列出要忽略的文件模式。.gitignore文件的格式规范如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;所有空行或注释都会被忽略&lt;/li&gt;
&lt;li&gt;可以使用标准glob模式匹配&lt;/li&gt;
&lt;li&gt;匹配模式最后跟‘/’表示要忽略的是目录&lt;/li&gt;
&lt;li&gt;要排除指定模式以外的文件，可以在模式前加‘!’取反&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;查看文件之间的区别：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;git diff    #比较的是工作目录中当前文件和暂存区域的文件快照的区别
git diff --cache    #比较的是暂存区域和上次提交的快照之间的区别（也可以使用--staged）
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;提交更新： &lt;code&gt;git commit [-m '...']&lt;/code&gt; 。加上&lt;code&gt;-a&lt;/code&gt;选项，Git会自动把所有已经&lt;em&gt;跟踪过&lt;/em&gt;的文件暂存起来一并提交，可以跳过&lt;code&gt;git add&lt;/code&gt;步骤。&lt;/p&gt;
&lt;p&gt;移除文件：删除已跟踪的文件，用&lt;code&gt;git rm&lt;/code&gt;，并连带从工作目录中删除。如果只是简单地从工作目录中删除，则查看状态会发现在&lt;code&gt;changed but not updated&lt;/code&gt;中，这时需再运行&lt;code&gt;git rm&lt;/code&gt;进行移除。如果在删除之间修改过并且已经放入暂存区域，则必须要用强制删除选项-f，以防误删除文件后丢失修改的内容。如果要删除已跟踪的文件，但是不要删除在工作目录中的文件：&lt;code&gt;git rm --cached&lt;/code&gt;。删除文件可以用glob模式匹配，不过&lt;code&gt;*&lt;/code&gt;前最好加上&lt;code&gt;\&lt;/code&gt;，以免被Shell先进行匹配。&lt;/p&gt;
&lt;h3&gt;三、查看提交历史&lt;/h3&gt;

&lt;p&gt;git log&lt;/p&gt;
&lt;p&gt;-p:显示详细修改日志；--stat：显示简要的增改行数统计；--pretty=format：定制要显示的记录格式。&lt;/p&gt;
&lt;h3&gt;四、撤销操作&lt;/h3&gt;

&lt;p&gt;修改最后一次提交：git commit --amend。可用于在提交完后发现漏掉文件或是提交信息写错。&lt;/p&gt;
&lt;p&gt;从暂存区域撤销：&lt;code&gt;git reset HEAD &amp;lt;file&amp;gt;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;取消对文件的修改：&lt;code&gt;git checkout -- &amp;lt;file&amp;gt;&lt;/code&gt;（限于对已跟踪的文件进行的修改）&lt;/p&gt;
&lt;h3&gt;五、远程仓库的使用&lt;/h3&gt;

&lt;p&gt;默认情况下，origin用来表示克隆下来的Git仓库。添加远程仓库：&lt;code&gt;git remote add [shortname][url]&lt;/code&gt;。抓取远端仓库有的而本地仓库的没有的信息：&lt;code&gt;git fetch [shortname]&lt;/code&gt;。&lt;strong&gt;注：fetch只是从远端仓库将数据拉到本地，并不自动合并。&lt;/strong&gt;若设置了某个分支用来跟踪某个远端仓库的分支，可以使用&lt;code&gt;git pull&lt;/code&gt;自动抓取数据下来，然后自动合并。推送数据至远端仓库：&lt;code&gt;git push [remote-name][branch]&lt;/code&gt;，将本地分支中的数据推到远端的仓库。&lt;/p&gt;
&lt;p&gt;查看远端仓库的信息：&lt;code&gt;git remote show [shortname]&lt;/code&gt;。远端仓库重命名：&lt;code&gt;git remote rename&lt;/code&gt;；远端仓库删除：&lt;code&gt;git remote remove&lt;/code&gt;&lt;/p&gt;
&lt;h3&gt;六、打标签&lt;/h3&gt;

&lt;p&gt;Git中使用的标签有两种：一种是轻量级的，一种是含附注的。轻量级的就是指向特定提交对象的引用，对应提交对象的校验和信息。含附注的标签在Git仓库中是独立的对象，它有自身的校验和信息。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;小技巧&lt;/strong&gt;创建别名：类似&lt;code&gt;git config --global alias.ci commit&lt;/code&gt;的，对应&lt;code&gt;git commit&lt;/code&gt;&lt;/p&gt;
&lt;h2 id='branch'&gt;分支&lt;/h2&gt;

&lt;p&gt;在Git中提交时，会保存一个提交对象，它包含一个指向暂存内容快照的指针、作者和相关附属信息，以及一定数量的指向该提交对象直接祖先的指针。举个例子，假设在工作目录中有三个文件，暂存后会对每个文件计算一个哈希字符串，然后将当前版本的文件快照保存到仓库中，并将哈希字符串加入暂存区域，每个文件文件都会作为一个blob对象保存到暂存区域。当使用git commit新建一个提交对象时，Git会先计算每一个子目录的校验和，然后在仓库中将这些目录保存为树(tree)对象，之后Git创建的提交(commit)对象除了包含相关提交信息以外还会包含一个指向这个树对象的指针。之后再做一次修改并提交后，新的提交对象就会指向之前的一个提交对象，如图：&lt;img alt="" src="http://7xn66o.com1.z0.glb.clouddn.com/progit/3.jpg" /&gt;&lt;img alt="" src="http://7xn66o.com1.z0.glb.clouddn.com/progit/4.jpg" /&gt;&lt;/p&gt;
&lt;p&gt;Git中的分支本质上就是一个指向commit对象的指针，Git默认使用master作为分支的默认名字。&lt;img alt="" src="http://7xn66o.com1.z0.glb.clouddn.com/progit/5.jpg" /&gt;&lt;/p&gt;
&lt;p&gt;在当前commit对象上创建一个新分支：&lt;code&gt;git branch &amp;lt;branch-name&amp;gt;&lt;/code&gt;。在Git中有一个HEAD指针，它指向当前正在工作的分支。git branch仅仅是新建一个分支，还需要切换到新建的分支&lt;code&gt;git checkout &amp;lt;branch&amp;gt;&lt;/code&gt;。Git分支实际上就是一个仅包含41个字符（所指对象的检验和和一个换行符）的文件。&lt;code&gt;git checkout -b &amp;lt;branch&amp;gt;&lt;/code&gt;创建分支并切换。&lt;/p&gt;
&lt;h3&gt;合并&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;git merge &amp;lt;branch&amp;gt;&lt;/code&gt; 在当前分支上合并另外一个分支。&lt;/p&gt;
&lt;p&gt;一些简单合并，如果当前分支是要合并的分支的直接上游，Git只需把指针向右移动，称为Fast Forward。如果是如图所示的合并，则Git会将两个末端分支（C4,C5)和它们的共同祖先(c2)一起做一个计算，并创建一个提交对象，这称为合并提交。&lt;img alt="" src="http://7xn66o.com1.z0.glb.clouddn.com/progit/6.jpg" /&gt;。有时候如果修改了同一个文件的同一个部分，则合并并不会很顺利，因为Git并不能决定使用那一个，于是就会停下来等待手工解决冲突。Git会在有冲突的文件中标记，用'======'来区分两个版本。&lt;/p&gt;
&lt;h3&gt;管理分支&lt;/h3&gt;

&lt;p&gt;git branch -v 可以看到有哪些分支。--merge,--no-merge查看合并的和未合并的分支。-d 删除分支。&lt;/p&gt;
&lt;h3&gt;远程分支&lt;/h3&gt;

&lt;p&gt;远程分支是对远程仓库的索引，它们是一些无法移动的分支，只有在进行Git的网络活动时才会更新。远程分支就像书签，提醒着上次连接远程仓库时上面各分支的位置。用(远程仓库名)/(远程分支名)来表示。&lt;/p&gt;
&lt;p&gt;获取远程分支上的更新：&lt;code&gt;git fetch &amp;lt;remote&amp;gt;&lt;/code&gt;；推送更新：&lt;code&gt;git push &amp;lt;remote&amp;gt; &amp;lt;branch&amp;gt;&lt;/code&gt;。&lt;strong&gt;注：在fetch抓来新的远程分支后不会有一个新的serverfix分支，而是只有一个无法移动的origin/serverfix分支，可以通过&lt;code&gt;git checkout -b serverfix origin/serverfix&lt;/code&gt;新建一个一样的serverfix分支来继续开发。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;跟踪分支：从远程分支中检出的本地分支称为跟踪分支。在跟踪分支中输入git push，Git会自动判断向哪个服务器的哪个分支推送更新，同样输入git pull会自动判断向哪个服务器的哪个分支获取更新，并合并到本地分支。在克隆仓库时，通常会自动创建一个master分支用于跟踪origin/master。可以通过&lt;code&gt;git checkout -b &amp;lt;branch&amp;gt; &amp;lt;remote&amp;gt;/&amp;lt;branch&amp;gt;&lt;/code&gt;或是&lt;code&gt;git checkout --track &amp;lt;remote&amp;gt;/&amp;lt;branch&amp;gt;&lt;/code&gt;来创建跟踪分支。&lt;/p&gt;
&lt;h3&gt;衍合&lt;/h3&gt;

&lt;p&gt;衍合就是把在一个分支里的修改在另一个分支里重放一遍。&lt;code&gt;git rebase [] []&lt;/code&gt;如图：&lt;img alt="" src="http://7xn66o.com1.z0.glb.clouddn.com/progit/7.jpg" /&gt;&lt;img alt="" src="http://7xn66o.com1.z0.glb.clouddn.com/progit/8.jpg" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注：&lt;/strong&gt;永远不要衍合那些已经推送到远程仓库的更新。&lt;/p&gt;
&lt;h2 id="tool"&gt;工具&lt;/h2&gt;

&lt;h3&gt;祖先引用&lt;/h3&gt;

&lt;p&gt;有一种指明某个提交的方法是通过其祖先。若在某个引用之后添加&lt;code&gt;^&lt;/code&gt;，表示此次提交的父提交，&lt;code&gt;^2&lt;/code&gt;表示此次合并提交的第二个父提交。&lt;code&gt;~&lt;/code&gt;表示此次提交的父提交，&lt;code&gt;~2&lt;/code&gt;表示此次提交的父提交的父提交。&lt;/p&gt;
&lt;p&gt;双点语法可用于区分出从一个分支中可以获得而从另一个分支中无法获得的提交。eg：git log master..expr 表示可从expr中有而在master中没有的提交。三点语法指定被两个分支中的一个包含而又不被两个同时包含的提交（类似于异或）eg：git log --left-right master...expr&lt;/p&gt;
&lt;h3&gt;Git交互工具&lt;/h3&gt;

&lt;p&gt;git add -i&lt;/p&gt;
&lt;h3&gt;储藏&lt;/h3&gt;

&lt;p&gt;储藏可以获取工作目录的中间状态，也就是修改过的跟踪文件和暂存文件的变更但还未提交，并将其保存到一个堆栈中，以便以后重新利用。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;git stash
git stash list    #查看现有储藏
git statsh apply  #重新利用储藏
git stash pop     #重新利用储藏，并将其从堆栈中移走
git stash branch &amp;lt;branch&amp;gt;  #创建一个新分支用来恢复储藏的工作
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;重写提交历史&lt;/h3&gt;

&lt;p&gt;改变最后一次提交：git commit --amend &lt;em&gt;注：&lt;/em&gt;不要在最后一次提交被推送后还去重写。&lt;/p&gt;
&lt;h3&gt;使用Git调试&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;git blame -L &amp;lt;行号范围‘，’号隔开&amp;gt; &amp;lt;file&amp;gt;&lt;/code&gt;：会显示对文件中每一行进行修改的最后一次提交&lt;/p&gt;
&lt;h3&gt;子模块&lt;/h3&gt;

&lt;p&gt;Git允许将一个Git库作为另一个的仓库的子目录，可以克隆另外一个仓库到项目中并且保持自身的提交相对独立。&lt;code&gt;git submodule add &amp;lt;url&amp;gt;&lt;/code&gt;。&lt;/p&gt;
&lt;h2 id="manage"&gt;自定义Git&lt;/h2&gt;

&lt;h3&gt;Git配置&lt;/h3&gt;

&lt;p&gt;Git的配置文件从一般到特殊分别是：/etc/gitconfig、~/.gitconfig、.git/config&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;core.editor：编译器
core.pager：分页器
commit.template：提交模板
color.ui：打开终端默认着色
core.autocrlf：设置成input表示在提交时把CRLF转换成LF，签出时不转换，这样在Windows系统中保留CRLF，在MAC和LINUX系统和仓库中保留LF
core.whitespace：探测和修正空白
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;在git push时无需输入用户名和密码：&lt;code&gt;git config --global credential.helper store&lt;/code&gt;，输入一次用户名和密码后默认会生成一个.git-credentials文件，权限应是600。&lt;/p&gt;</summary></entry></feed>